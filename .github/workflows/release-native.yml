name: Release Native App

on:
  push:
    branches:
      - staging
      - main
    paths:
      - 'apps/native/**'
      - '.github/workflows/release-native.yml'
      - '.github/actions/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'prerelease'
        type: choice
        options:
          - prerelease
          - release

permissions:
  contents: write

env:
  PNPM_VERSION: 8
  NODE_VERSION: 20

jobs:
  # ========================================
  # „Éì„É´„Éâ: macOSÂêë„Åë„Éç„Ç§„ÉÜ„Ç£„Éñ„Ç¢„Éó„É™
  # ========================================
  build-native:
    name: Build macOS App
    runs-on: macos-14
    outputs:
      version: ${{ steps.version.outputs.version }}
      artifact-name: ${{ steps.artifact.outputs.name }}
      environment: ${{ steps.env.outputs.environment }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "üì¶ Environment: staging"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "üöÄ Environment: production"
          else
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "üîß Environment: development"
          fi

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}
          run_install: false

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Get version
        id: version
        run: |
          cd apps/native
          VERSION=$(node -p "require('./package.json').version")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "üìã Version: $VERSION"

      - name: Setup Apple Code Signing (Production only)
        if: ${{ steps.env.outputs.environment == 'production' && env.APPLE_CERTIFICATE_BASE64 != '' && env.APPLE_CERTIFICATE_PASSWORD != '' }}
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          echo "üîë Setting up Apple Developer ID code signing for production..."
          
          # Create keychain
          security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          
          # Import certificate
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          
          # Set signing identity
          echo "APPLE_SIGNING_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep 'Developer ID Application' | head -1 | grep -o '[A-Z0-9]\{40\}')" >> $GITHUB_ENV
          
          echo "‚úÖ Code signing setup completed for production"

      - name: Build Tauri app (Environment-specific)
        env:
          APP_ENV: ${{ steps.env.outputs.environment }}
        run: |
          echo "=== Build Environment ==="
          echo "APP_ENV: $APP_ENV"
          echo "GITHUB_REF: ${{ github.ref }}"
          echo "Current directory: $(pwd)"
          echo "=== Directory structure ==="
          
          if [ -d "apps/native" ]; then
            echo "‚úÖ apps/native exists"
            ls -la apps/native/
          else
            echo "‚ùå apps/native not found"
            exit 1
          fi
          
          # Environment-specific signing configuration
          if [[ "$APP_ENV" == "production" ]] && [[ -n "$APPLE_SIGNING_IDENTITY" ]]; then
            echo "üîè Building with Apple Developer ID signing for production..."
            export APPLE_CODESIGN_IDENTITY="$APPLE_SIGNING_IDENTITY"
            export TAURI_SIGNING_PRIVATE_KEY="${{ secrets.TAURI_PRIVATE_KEY }}"
            export TAURI_SIGNING_PRIVATE_KEY_PASSWORD="${{ secrets.TAURI_KEY_PASSWORD }}"
          else
            echo "üß™ Building with ad-hoc signing for $APP_ENV"
            export APPLE_CODESIGN_IDENTITY="-"
            # Skip Tauri signing for staging environment
            if [[ "$APP_ENV" == "staging" ]]; then
              echo "üö´ Skipping Tauri signing for staging environment"
              unset TAURI_SIGNING_PRIVATE_KEY
              unset TAURI_SIGNING_PRIVATE_KEY_PASSWORD
            elif [[ -n "${{ secrets.TAURI_PRIVATE_KEY }}" ]]; then
              echo "üìù Tauri signing keys detected, setting up..."
              export TAURI_SIGNING_PRIVATE_KEY="${{ secrets.TAURI_PRIVATE_KEY }}"
              export TAURI_SIGNING_PRIVATE_KEY_PASSWORD="${{ secrets.TAURI_KEY_PASSWORD }}"
              echo "‚úÖ Tauri signing environment variables set"
            else
              echo "‚ö†Ô∏è No Tauri signing keys found for $APP_ENV"
            fi
          fi
          
          export CI=true
          export SKIP_JENKINS=1
          
          echo "üèóÔ∏è Starting environment-specific build process..."
          cd apps/native
          
          echo "=== Environment-specific Build ==="
          case "$APP_ENV" in
            "staging")
              echo "üîß Building for staging environment"
              pnpm tauri:build:staging 2>&1 | tee ../build.log || {
                echo "‚ùå Staging build failed, trying fallback..."
                APP_ENV=staging pnpm tauri build --bundles dmg --verbose
              }
              ;;
            "production")
              echo "üöÄ Building for production environment"
              pnpm tauri:build:production 2>&1 | tee ../build.log || {
                echo "‚ùå Production build failed, trying fallback..."
                APP_ENV=production pnpm tauri build --bundles dmg --verbose
              }
              ;;
            *)
              echo "üî® Building for development environment"
              pnpm tauri:build:dev 2>&1 | tee ../build.log || {
                echo "‚ùå Development build failed, trying fallback..."
                APP_ENV=development pnpm tauri build --bundles dmg --verbose
              }
              ;;
          esac
          
          cd ../..

      - name: Fix macOS code signing resources
        run: |
          cd apps/native
          echo "üîß Fixing macOS code signing resources..."
          
          # Find the DMG file
          DMG_PATH=$(find src-tauri/target -name "*.dmg" | head -1)
          
          if [ -n "$DMG_PATH" ]; then
            echo "üì¶ Found DMG at: $DMG_PATH"
            
            # Create temporary directory
            TEMP_DIR=$(mktemp -d)
            
            # Mount the DMG
            hdiutil attach "$DMG_PATH" -mountpoint "$TEMP_DIR/mount" -readonly -noautoopen
            
            # Check and copy only relevant DMG contents
            mkdir -p "$TEMP_DIR/dmg_contents"
            
            # List mounted contents for debugging
            echo "üîç Mounted DMG contents:"
            ls -la "$TEMP_DIR/mount/"
            
            # Verify this is actually our DMG and not system Applications
            if [ -f "$TEMP_DIR/mount/Applications" ]; then
              # Applications is a symlink (normal DMG)
              echo "‚úÖ Found Applications symlink"
              cp -r "$TEMP_DIR/mount"/* "$TEMP_DIR/dmg_contents/"
            elif [ -d "$TEMP_DIR/mount/Applications" ] && [ "$(ls -1 "$TEMP_DIR/mount/" | wc -l)" -gt 10 ]; then
              # Applications is a directory with many items (system mount - ERROR)
              echo "‚ùå ERROR: Mounted system Applications folder instead of DMG"
              echo "This indicates a problem with DMG creation or mounting"
              exit 1
            else
              # Copy selectively to avoid system files
              echo "‚ö†Ô∏è Selective copy to avoid system files"
              for item in "$TEMP_DIR/mount"/*; do
                if [[ "$(basename "$item")" == *.app ]] || [[ "$(basename "$item")" == "Applications" ]]; then
                  cp -r "$item" "$TEMP_DIR/dmg_contents/"
                fi
              done
            fi
            
            # Find the app in the copied contents
            APP_NAME=$(ls "$TEMP_DIR/dmg_contents" | grep "\.app$" | head -1)
            if [ -z "$APP_NAME" ]; then
              echo "‚ùå No app found in DMG contents"
              exit 1
            fi
            
            # Unmount the DMG
            hdiutil detach "$TEMP_DIR/mount"
            
            # Apply the fix to the app while preserving its name
            echo "üîß Applying code signing fix to $APP_NAME..."
            codesign --force --deep --sign - "$TEMP_DIR/dmg_contents/$APP_NAME"
            
            # Verify the fix
            echo "üîç Verifying code signing fix..."
            codesign -dvvv "$TEMP_DIR/dmg_contents/$APP_NAME" | grep -E "(Sealed Resources|Info.plist)" || echo "‚ö†Ô∏è Verification incomplete"
            
            # Create new DMG with the fixed app and preserved structure
            DMG_NAME=$(basename "$DMG_PATH")
            TEMP_DMG_PATH="${DMG_PATH%.*}_temp"
            echo "üì¶ Creating new DMG with fixed app and preserved structure..."
            VOLUME_NAME="prompalette-${APP_ENV}"
            hdiutil create -srcfolder "$TEMP_DIR/dmg_contents" -volname "$VOLUME_NAME" -ov -format UDZO "$TEMP_DMG_PATH"
            
            # Replace the original DMG
            mv "$TEMP_DMG_PATH.dmg" "$DMG_PATH"
            
            # Clean up
            rm -rf "$TEMP_DIR"
            
            echo "‚úÖ Code signing resources fixed in DMG"
          else
            echo "‚ùå No DMG found to fix"
          fi
          
          cd ../..

      - name: Verify build output
        run: |
          echo "=== Checking for DMG files ==="
          find apps/native/src-tauri/target -name "*.dmg" -type f || echo "No DMG files found"

      - name: Find DMG files
        id: find_dmg
        run: |
          cd apps/native
          echo "=== Searching for DMG files ==="
          
          # Find DMG files with prioritization
          DMG_FILES=$(find src-tauri/target -name "*.dmg" -type f | grep -v "rw\." | sort)
          
          if [ -z "$DMG_FILES" ]; then
            echo "‚ùå No DMG files found!"
            exit 1
          fi
          
          echo "Found DMG files:"
          echo "$DMG_FILES"
          
          # Prioritize universal build
          SELECTED_DMG=""
          if echo "$DMG_FILES" | grep -q "universal-apple-darwin"; then
            SELECTED_DMG=$(echo "$DMG_FILES" | grep "universal-apple-darwin" | head -n1)
            echo "‚úÖ Selected universal DMG: $SELECTED_DMG"
          else
            SELECTED_DMG=$(echo "$DMG_FILES" | head -n1)
            echo "‚úÖ Selected first available DMG: $SELECTED_DMG"
          fi
          
          echo "dmg_path=$SELECTED_DMG" >> $GITHUB_OUTPUT
          echo "dmg_name=$(basename $SELECTED_DMG)" >> $GITHUB_OUTPUT

      - name: Notarize macOS app (Production only)
        if: ${{ steps.env.outputs.environment == 'production' && env.APPLE_SIGNING_IDENTITY != '' && env.APPLE_ID != '' && env.APPLE_PASSWORD != '' && env.APPLE_TEAM_ID != '' }}
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          cd apps/native
          DMG_PATH="${{ steps.find_dmg.outputs.dmg_path }}"
          
          echo "üçé Notarizing production app with Apple..."
          
          # Submit for notarization
          xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait
          
          # Staple the notarization ticket
          xcrun stapler staple "$DMG_PATH"
          
          echo "‚úÖ Notarization completed for production"

      - name: Set artifact name
        id: artifact
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ENV="${{ steps.env.outputs.environment }}"
          if [[ "$ENV" == "production" ]]; then
            NAME="prompalette-${VERSION}-macos"
          else
            NAME="prompalette-${VERSION}-${ENV}-macos"
          fi
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "üì¶ Artifact name: $NAME"

      - name: Create artifact directory
        run: |
          cd apps/native
          DMG_PATH="${{ steps.find_dmg.outputs.dmg_path }}"
          
          # Create artifact directory
          mkdir -p "${{ steps.artifact.outputs.name }}"
          
          # Copy DMG
          cp "$DMG_PATH" "${{ steps.artifact.outputs.name }}/"
          
          echo "‚úÖ Artifact created with DMG: $(basename "$DMG_PATH")"
          ls -la "${{ steps.artifact.outputs.name }}/"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.artifact.outputs.name }}
          path: apps/native/${{ steps.artifact.outputs.name }}/
          retention-days: 7

  # ========================================
  # „Éó„É¨„É™„É™„Éº„ÇπÔºàstagingÂêë„ÅëÔºâ
  # ========================================
  pre-release:
    name: Staging Pre-release
    needs: build-native
    if: github.ref == 'refs/heads/staging'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-native.outputs.artifact-name }}
          path: ./dist

      - name: Verify artifact contents
        run: |
          echo "=== Verifying downloaded artifacts ==="
          if [ -d "./dist" ] && [ -n "$(find ./dist -name '*.dmg' -type f)" ]; then
            echo "‚úÖ DMG files found:"
            find ./dist -name '*.dmg' -type f
          else
            echo "‚ùå No DMG files found in artifacts"
            exit 1
          fi

      - name: Generate release notes
        id: notes
        run: |
          ENV="${{ needs.build-native.outputs.environment }}"
          VERSION="${{ needs.build-native.outputs.version }}"
          
          case "$ENV" in
            "staging")
              echo "## üöß Staging Pre-release v${VERSION}-staging.${{ github.run_number }}" > notes.md
              echo "" >> notes.md
              echo "### üìÖ Build Information" >> notes.md
              echo "- **Version**: ${VERSION}" >> notes.md
              echo "- **Build**: #${{ github.run_number }}" >> notes.md
              echo "- **Branch**: staging" >> notes.md
              echo "- **Commit**: ${{ github.sha }}" >> notes.md
              echo "" >> notes.md
              echo "### ‚ö†Ô∏è Important Notes" >> notes.md
              echo "This is a pre-release build for testing purposes." >> notes.md
              echo "" >> notes.md
              echo "### üçé macOS Installation" >> notes.md
              echo "1. Download the DMG file" >> notes.md
              echo "2. Open the DMG and drag prompalette to Applications" >> notes.md
              echo "3. On first launch, right-click and select 'Open' to bypass Gatekeeper" >> notes.md
              ;;
            *)
              echo "## üîß Development Build v${VERSION}-dev.${{ github.run_number }}" > notes.md
              ;;
          esac

      - name: Skip updater signature for staging
        run: |
          echo "üß™ Staging build - skipping Tauri updater signature"
          echo "‚ÑπÔ∏è Staging builds use ad-hoc signing and don't require updater manifests"
          echo "üöÄ Users can download DMG directly from releases"

      - name: Create pre-release
        uses: softprops/action-gh-release@v2
        with:
          prerelease: true
          tag_name: v${{ needs.build-native.outputs.version }}-${{ needs.build-native.outputs.environment }}.${{ github.run_number }}
          name: v${{ needs.build-native.outputs.version }}-${{ needs.build-native.outputs.environment }}.${{ github.run_number }}
          body_path: notes.md
          files: |
            ./dist/*.dmg
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ========================================
  # Êú¨Áï™„É™„É™„Éº„Çπ
  # ========================================
  release:
    name: Production Release
    needs: build-native
    if: |
      github.ref == 'refs/heads/main' || 
      (github.event_name == 'workflow_dispatch' && inputs.release_type == 'release')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-native.outputs.artifact-name }}
          path: ./dist

      - name: Verify artifact contents
        run: |
          echo "=== Verifying downloaded artifacts ==="
          if [ -d "./dist" ] && [ -n "$(find ./dist -name '*.dmg' -type f)" ]; then
            echo "‚úÖ DMG files found:"
            find ./dist -name '*.dmg' -type f
          else
            echo "‚ùå No DMG files found in artifacts"
            exit 1
          fi

      - name: Generate changelog
        run: |
          VERSION="${{ needs.build-native.outputs.version }}"
          echo "## üéâ Release v${VERSION}" > changelog.md
          echo "" >> changelog.md
          echo "### üìù Changes since last release" >> changelog.md
          
          # Get commits since last tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -n "$LAST_TAG" ]; then
            echo "Changes since ${LAST_TAG}:" >> changelog.md
            git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" >> changelog.md
          else
            echo "Initial release" >> changelog.md
          fi
          
          echo "" >> changelog.md
          echo "" >> changelog.md
          echo "### üçé macOS Installation" >> changelog.md
          echo "1. Download the DMG file below" >> changelog.md
          echo "2. Open the DMG and drag prompalette to Applications" >> changelog.md
          echo "3. On first launch, right-click the app and select 'Open' to bypass Gatekeeper" >> changelog.md
          echo "" >> changelog.md
          echo "### üîß System Requirements" >> changelog.md
          echo "- macOS 10.15 or later" >> changelog.md
          echo "- Supports both Intel and Apple Silicon Macs" >> changelog.md

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check if release exists
        id: check_release
        run: |
          VERSION="${{ needs.build-native.outputs.version }}"
          if gh release view "v${VERSION}" > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Release v${VERSION} already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "üì¶ Release v${VERSION} does not exist yet"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate updater signature
        if: steps.check_release.outputs.exists == 'false'
        id: signature
        uses: ./.github/actions/generate-updater-signature
        with:
          artifact-name: ${{ needs.build-native.outputs.artifact-name }}
          environment: production
          tauri-private-key: ${{ secrets.TAURI_PRIVATE_KEY }}
          tauri-key-password: ${{ secrets.TAURI_KEY_PASSWORD }}
          pnpm-version: ${{ env.PNPM_VERSION }}

      - name: Create production updater manifest
        if: steps.check_release.outputs.exists == 'false'
        id: manifest
        uses: ./.github/actions/create-updater-manifest
        with:
          version: v${{ needs.build-native.outputs.version }}
          release-notes-file: changelog.md
          signature: ${{ steps.signature.outputs.signature }}
          dmg-file: ${{ steps.signature.outputs.dmg-file }}
          repository: ${{ github.repository }}
          manifest-filename: updater-manifest.json

      - name: Create production release
        if: steps.check_release.outputs.exists == 'false'
        uses: softprops/action-gh-release@v2
        with:
          prerelease: false
          tag_name: v${{ needs.build-native.outputs.version }}
          name: v${{ needs.build-native.outputs.version }}
          body_path: changelog.md
          files: |
            ./dist/*.dmg
            ./updater-manifest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update existing release
        if: steps.check_release.outputs.exists == 'true'
        run: |
          echo "Release v${{ needs.build-native.outputs.version }} already exists. Skipping creation."
          echo "To create a new release, please update the version in package.json."